//line /Users/Martin_Ghazaryan/VCProjects/xk6-mongo/mongo.go:1:1
package xk6_mongo; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"fmt"
	"log"
	"strings"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	k6modules "go.k6.io/k6/js/modules"
)

// Register the extension on module initialization, available to
// import from JS as "k6/x/mongo".
func init() {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__0[0], 1) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__0[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__0[2], 0) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__0[3], 1);
	k6modules.Register("k6/x/mongo", new(Mongo))
}

// Mongo is the k6 extension for a Mongo client.
type Mongo struct{}

// Client is the Mongo client wrapper.
type Client struct {
	client *mongo.Client
}

type UpsertOneModel struct {
	Query  any `json:"query"`
	Update any `json:"update"`
}

// NewClient represents the Client constructor (i.e. `new mongo.Client()`) and
// returns a new Mongo client object.
// connURI -> mongodb://username:password@address:port/db?connect=direct
func (m *Mongo) NewClient(connURI string) *Client {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__1[0], 1) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__1[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__1[2], 1) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__1[3], 1);
	return m.NewClientWithOptions(connURI, nil)
}

func (*Mongo) NewClientWithOptions(connURI string, opts any) *Client {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__2[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__2[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__2[2], 2) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__2[3], 1);
	log.Print("start creating new client")

	clientOptions, err := prepareClientOptions(connURI, opts)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__2[6], 1);
		log.Printf("Error while preparing client options: %v", err)
		return nil
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__2[4], 1);client, err := mongo.Connect(context.Background(), clientOptions)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__2[7], 1);
		log.Printf("Error while establishing a connection to MongoDB: %v", err)
		return nil
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__2[5], 1);log.Print("created new client")
	return &Client{client: client}
}

func (c *Client) Insert(database string, collection string, doc any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__3[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__3[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__3[2], 3) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__3[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	_, err := col.InsertOne(context.Background(), doc)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__3[5], 1);
		log.Printf("Error while inserting document: %v", err)
		return err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__3[4], 1);log.Print("Document inserted successfully")
	return nil
}

func (c *Client) InsertMany(database string, collection string, docs []any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__4[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__4[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__4[2], 4) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__4[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	_, err := col.InsertMany(context.Background(), docs)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__4[5], 1);
		log.Printf("Error while inserting multiple documents: %v", err)
		return err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__4[4], 1);return nil
}

func (c *Client) Upsert(database string, collection string, filter any, upsert any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__5[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__5[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__5[2], 5) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__5[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	opts := options.Update().SetUpsert(true)
	_, err := col.UpdateOne(context.Background(), filter, upsert, opts)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__5[5], 1);
		log.Printf("Error while performing upsert: %v", err)
		return err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__5[4], 1);return nil
}

const errDecodingDocuments = "Error while decoding documents: %v"

func (c *Client) Find(database string, collection string, filter any, sort any, limit int64) ([]bson.M, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__6[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__6[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__6[2], 6) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__6[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	opts := options.Find().SetSort(sort).SetLimit(limit)
	cur, err := col.Find(context.Background(), filter, opts)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__6[6], 1);
		log.Printf("Error while finding documents: %v", err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__6[4], 1);var results []bson.M
	if err = cur.All(context.Background(), &results); err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__6[7], 1);
		log.Printf(errDecodingDocuments, err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__6[5], 1);return results, nil
}

func (c *Client) Aggregate(database string, collection string, pipeline any) ([]bson.M, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__7[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__7[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__7[2], 7) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__7[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	cur, err := col.Aggregate(context.Background(), pipeline)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__7[6], 1);
		log.Printf("Error while aggregating: %v", err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__7[4], 1);var results []bson.M
	if err = cur.All(context.Background(), &results); err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__7[7], 1);
		log.Printf(errDecodingDocuments, err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__7[5], 1);return results, nil
}

func (c *Client) FindOne(database string, collection string, filter any) (bson.M, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__8[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__8[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__8[2], 8) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__8[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	var result bson.M
	err := col.FindOne(context.Background(), filter).Decode(&result)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__8[5], 1);
		log.Printf("Error while finding the document: %v", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__8[4], 1);return result, nil
}

func (c *Client) UpdateOne(database string, collection string, filter any, data any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__9[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__9[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__9[2], 9) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__9[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)

	update, err := prepareUpdateDocument(data)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__9[6], 1);
		log.Printf("Error while preparing update document: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__9[4], 1);_, err = col.UpdateOne(context.Background(), filter, update)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__9[7], 1);
		log.Printf("Error while updating the document: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__9[5], 1);return nil
}

func (c *Client) UpdateMany(database string, collection string, filter any, data any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__10[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__10[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__10[2], 10) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__10[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)

	update, err := prepareUpdateDocument(data)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__10[6], 1);
		log.Printf("Error while preparing update document: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__10[4], 1);_, err = col.UpdateMany(context.Background(), filter, update)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__10[7], 1);
		log.Printf("Error while updating the documents: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__10[5], 1);return nil
}

func (c *Client) FindAll(database string, collection string) ([]bson.M, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__11[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__11[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__11[2], 11) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__11[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	cur, err := col.Find(context.Background(), bson.D{{}})
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__11[6], 1);
		log.Printf("Error while finding documents: %v", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__11[4], 1);var results []bson.M
	if err = cur.All(context.Background(), &results); err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__11[7], 1);
		log.Printf(errDecodingDocuments, err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__11[5], 1);return results, nil
}

func (c *Client) DeleteOne(database string, collection string, filter any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__12[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__12[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__12[2], 12) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__12[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	_, err := col.DeleteOne(context.Background(), filter)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__12[5], 1);
		log.Printf("Error while deleting the document: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__12[4], 1);return nil
}

func (c *Client) DeleteMany(database string, collection string, filter any) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__13[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__13[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__13[2], 13) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__13[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	_, err := col.DeleteMany(context.Background(), filter)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__13[5], 1);
		log.Printf("Error while deleting the documents: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__13[4], 1);return nil
}

func (c *Client) Distinct(database string, collection string, field string, filter any) ([]any, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__14[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__14[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__14[2], 14) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__14[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	result, err := col.Distinct(context.Background(), field, filter)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__14[5], 1);
		log.Printf("Error while getting distinct values: %v", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__14[4], 1);return result, nil
}

func (c *Client) DropCollection(database string, collection string) error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__15[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__15[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__15[2], 15) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__15[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	err := col.Drop(context.Background())
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__15[5], 1);
		log.Printf("Error while dropping the collection: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__15[4], 1);return nil
}

func (c *Client) CountDocuments(database string, collection string, filter any) (int64, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__16[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__16[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__16[2], 16) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__16[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	count, err := col.CountDocuments(context.Background(), filter)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__16[5], 1);
		log.Printf("Error while counting documents: %v", err)
		return 0, err
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__16[4], 1);return count, nil
}

func (c *Client) FindOneAndUpdate(database string, collection string, filter any, update any) (*mongo.SingleResult, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__17[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__17[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__17[2], 17) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__17[3], 1);
	db := c.client.Database(database)
	col := db.Collection(collection)
	opts := options.FindOneAndUpdate().SetReturnDocument(options.After)
	result := col.FindOneAndUpdate(context.Background(), filter, update, opts)
	if result.Err() != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__17[5], 1);
		log.Printf("Error while finding and updating document: %v", result.Err())
		return nil, result.Err()
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__17[4], 1);return result, nil
}

func (c *Client) Disconnect() error {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__18[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__18[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__18[2], 18) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__18[3], 1);
	err := c.client.Disconnect(context.Background())
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__18[5], 1);
		log.Printf("Error while disconnecting from the database: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__18[4], 1);return nil
}

func prepareClientOptions(connURI string, opts any) (*options.ClientOptions, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__19[0], 8) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__19[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__19[2], 19) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[3], 1);
	switch v := opts.(type) {
	case nil:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[4], 1);
		return options.Client().ApplyURI(connURI), nil
	case *options.ClientOptions:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[5], 1);
		if v == nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[10], 1);
			return nil, fmt.Errorf("client options cannot be nil")
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[6], 1);v.ApplyURI(connURI)
		return v, nil
	case map[string]any:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[7], 1);
		return clientOptionsFromMap(connURI, v)
	case bson.M:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[8], 1);
		return clientOptionsFromMap(connURI, map[string]any(v))
	default:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__19[9], 1);
		return nil, fmt.Errorf("unsupported client options type %T", opts)
	}
}

func clientOptionsFromMap(connURI string, raw map[string]any) (*options.ClientOptions, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__20[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__20[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__20[2], 20) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__20[3], 1);
	normalized := normalizeKeys(raw)
	clientOptions := options.Client().ApplyURI(connURI)

	bsonBytes, err := bson.Marshal(normalized)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__20[6], 1);
		return nil, fmt.Errorf("failed to marshal client options: %w", err)
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__20[4], 1);if err := bson.Unmarshal(bsonBytes, clientOptions); err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__20[7], 1);
		return nil, fmt.Errorf("failed to unmarshal client options: %w", err)
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__20[5], 1);return clientOptions, nil
}

func normalizeKeys(value any) any {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__21[0], 11) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__21[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__21[2], 21) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[3], 1);
	switch v := value.(type) {
	case map[string]any:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[4], 1);
		out := make(map[string]any, len(v))
		for key, val := range v {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[11], 1);
			out[toPascalCase(key)] = normalizeKeys(val)
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[5], 1);return out
	case bson.M:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[6], 1);
		out := make(map[string]any, len(v))
		for key, val := range v {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[12], 1);
			out[toPascalCase(key)] = normalizeKeys(val)
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[7], 1);return out
	case []any:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[8], 1);
		for i, val := range v {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[13], 1);
			v[i] = normalizeKeys(val)
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[9], 1);return v
	default:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__21[10], 1);
		return value
	}
}

var knownAcronyms = map[string]string{
	"api":  "API",
	"id":   "ID",
	"uri":  "URI",
	"tls":  "TLS",
	"ocsp": "OCSP",
}

func toPascalCase(input string) string {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__22[0], 13) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__22[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__22[2], 22) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[3], 1);
	if input == "" {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[7], 1);
		return ""
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[4], 1);segments := strings.FieldsFunc(input, func(r rune) bool {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[8], 1);
		switch r {
		case '_', '-', ' ':_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[9], 1);
			return true
		default:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[10], 1);
			return false
		}
	})
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[5], 1);for i, segment := range segments {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[11], 1);
		lowerSegment := strings.ToLower(segment)
		if replacement, ok := knownAcronyms[lowerSegment]; ok {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[14], 1);
			segments[i] = replacement
			continue
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[12], 1);if len(segment) == 0 {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[15], 1);
			continue
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[13], 1);runes := []rune(strings.ToLower(segment))
		runes[0] = []rune(strings.ToUpper(string(runes[0])))[0]
		segments[i] = string(runes)
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__22[6], 1);return strings.Join(segments, "")
}

func prepareUpdateDocument(data any) (any, error) {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__23[0], 14) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__23[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__23[2], 23) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[3], 1);
	if data == nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[6], 1);
		return nil, fmt.Errorf("update document cannot be nil")
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[4], 1);if isPipelineUpdate(data) || updateDocumentHasOperator(data) {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[7], 1);
		return data, nil
	}

	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[5], 1);switch doc := data.(type) {
	case bson.D:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[8], 1);
		return bson.D{{Key: "$set", Value: doc}}, nil
	case bson.M:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[9], 1);
		return bson.M{"$set": doc}, nil
	case map[string]any:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[10], 1);
		return bson.M{"$set": doc}, nil
	case bson.A:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[11], 1);
		return bson.M{"$set": doc}, nil
	default:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[12], 1);
		bytes, err := bson.Marshal(doc)
		if err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[15], 1);
			return nil, fmt.Errorf("failed to marshal update document: %w", err)
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[13], 1);var generic bson.M
		if err := bson.Unmarshal(bytes, &generic); err != nil {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[16], 1);
			return nil, fmt.Errorf("failed to unmarshal update document: %w", err)
		}
		_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__23[14], 1);return bson.M{"$set": generic}, nil
	}
}

func updateDocumentHasOperator(doc any) bool {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__24[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__24[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__24[2], 24) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__24[3], 1);
	switch value := doc.(type) {
	case bson.D:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__24[5], 1);
		return hasOperatorInKeysD(value)
	case bson.M:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__24[6], 1);
		return hasOperatorInKeysM(value)
	case map[string]any:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__24[7], 1);
		return hasOperatorInKeysMap(value)
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__24[4], 1);return false
}

func hasOperatorInKeysD(d bson.D) bool {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__25[0], 4) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__25[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__25[2], 25) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__25[3], 1);
	for _, elem := range d {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__25[5], 1);
		if strings.HasPrefix(elem.Key, "$") {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__25[6], 1);
			return true
		}
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__25[4], 1);return false
}

func hasOperatorInKeysM(m bson.M) bool {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__26[0], 4) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__26[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__26[2], 26) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__26[3], 1);
	for key := range m {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__26[5], 1);
		if strings.HasPrefix(key, "$") {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__26[6], 1);
			return true
		}
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__26[4], 1);return false
}

func hasOperatorInKeysMap(m map[string]any) bool {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__27[0], 4) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__27[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__27[2], 27) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__27[3], 1);
	for key := range m {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__27[5], 1);
		if strings.HasPrefix(key, "$") {_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__27[6], 1);
			return true
		}
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__27[4], 1);return false
}

func isPipelineUpdate(doc any) bool {_cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__28[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__28[1], goCover_5ac3efca9d9e_P) ; _cover_atomic_.StoreUint32(&goCover_5ac3efca9d9e__28[2], 28) ; _cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__28[3], 1);
	switch doc.(type) {
	case []bson.D, []bson.M, []any, bson.A:_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__28[5], 1);
		return true
	}
	_cover_atomic_.AddUint32(&goCover_5ac3efca9d9e__28[4], 1);return false
}

var _ = _cover_atomic_.LoadUint32
